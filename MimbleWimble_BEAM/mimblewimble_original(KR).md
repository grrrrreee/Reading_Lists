MimbleWimble(밈블윔블) </br>
저자 : Tom Elvis Jedusor</br>
19 July, 2016 
역자 : 박경덕, 박민서, 홍용빈 (이름순)

<h3>Introduction</h3> 1차 끝

비트코인은 최초로 시스템 상태를 검증하기 위한 데이터를 그 누구나 암호화된 방식으로 검증할 수 있는 금융 시스템이다.

이는 "블록체인"이라고 불리우는 공개 데이터베이스에 저장함으로써 완성된다. 진정으로 확인하고자 하는 사람은 이 상태를 전체 다운로드하고 모든 거래를 재실행시켜 보아야한다. 한편 대부분의 거래들은 실제 최종 상태에 영향을 미치지 않는다. (대부분 거래의 출력값은 한 거래 후에는 파괴된다.)

이 글을 쓰고있는 현재(2016년 7월), 블록체인에서 약 1억5천만 건의 거래가 있었고 이들을 실행하면 4백만개의 사용되지 않은 출력값이(UTXO) 생성된다. 

감사자가 출력값 자체에 대한 데이터만 검사하게 된다면 좋겠지만, 출력값이 이전 출력값 체인의 끝에 있는 경우에만 유효하고, 다음에 각각 서명되야 하기 때문에 이것은 불가능하다. 즉, 최종 상태의 유효성을 확인하기 위해서는 전체 블록체인(blockchain)을 검증해야 한다. (?)

여기에 이들 거래는 암호화된 원자성이라, 각 거래에 어떤 출력값이 투입되고 생성되는지가 명확하다. 그 결과로 나타나는 "거래그래프"는 많은 정보를 드러내며, 하위 계층을 감시하고 통제하는 사업 모델을 가진 많은 회사들의 분석 대상이 된다.(?) 이 방법은 사람들의 privacy 를 침해하고 심지어 위험에 빠뜨릴 수도 있다.

이에 대한 몇 가지 해결책이 제시되었다. 그렉 멕스월은 거래량을 암호화하는 방법을 찾았다, 거래 내용 자체는 가려지지만 그 총량이 옳다는 것을 증명해낼 수 있다.[1] 멕스웰 박사는 CoinJoin 이라는 방벙 역시 만들었다. CoinJoin 은 비트코인에서 사용된다. 거래를 interactively 하게 합쳐서 거래 그래프의 내용 자체를 명확하지 않게 한다. 니콜라스 반 사베르하겐은 거래 항목을 가리는 시스템을 개발했고, 더 나아가 거래 그래프 역시 가린다. (사용자와의 상호 작용이 필요 없다)[3]. 후에 셴 노에더는 두 가지 방법을 결합하여 맥스웰의 "confidential transactions"와 판 사버하겐의 내용 가리기 기능을 동시에 달성하였다. 

닥터 맥스웰의 Coinjoin은 상호작용을 필요로 하는 문제를 가지고 있다.(?) 위안 호라스 무튼 박사는 자유롭게 거래를 병합할 수 있게 함으로써 이것을 고쳤으나[5], 잠재적으로 더 느리고 신뢰하기 어려운 키쌍 기반의 암호학을 사용할 필요가 있었다. 그는 이것을 "일방 종합 서명"(OWAS)이라고 불렀다. 

OWAS는 그 거래를 블록으로 묶는 좋은 아이디어를 가지고 있었다. (glue 데이터와 함께) 블록끼리 묶을 수 있다고 생각해보자. 출력값이 생성되고 파괴되면 애시당초 존재하지 않는 것과 동일하다. 전체 체인의 유효성을 검사할 때, 사용자는 시스템에 돈이 입력되었을 때(비트코인 또는 모네로에서 각 블록마다 생성되는 새로운 화폐 또는 사이드 체인에 대한 peg-in들이 그 예시[6]) 와 마지막 사용되지 않은 출력값만 알면 된다. 나머지는 사라지고 잊혀져도 상관없다.

이제 우리는 Confidential Transactions를 통해 액수를 가리고 OWAS를 통해 거래 그래프를 부정확하게 하며 비트코인보다 적은 공간을 이용하여 사용자가 전체 블록체인을 검증할 수 있다. 그리고 또한 쌍 기반의 암호화나 새로운 가설 없이 비트코인처럼 일반적인 이산 로그 서명만 한다고 상상해보자. 여기 내가 제안하는 것이 있다.(?)

블록체인에서 모든 사용자의 정보에 대해 이야기하는 것을 막기에 나는 내 창작물을 Mimblewimble이라고 부른다. [7]

<h3>Confidential Transactions and OWAS </h3>

가장 먼저 해야 할 일은 비트코인 스크립트를 제거하는 것이다. 슬프지만, 너무 강력해서 일반 스크립트를 사용하여 거래를 병합하는 것은 불가능하다. 우리는 맥스웰 박사의 confidential transaction 이 출력값을 승인하기에 충분하고 또한 상호 작용 없이 결합 거래를 할 수 있다는 것을 증명할 것이다.(약간의 수정은 필요하다) 이는 사실상 OWAS와 동일하며, 중계 노드가 거래 수수료를 일부 취하거나 수신자가 거래 수수료를 변경할 수 있도록 한다. 비트코인이 할 수 없는 부가적인 기능들을 우리는 공짜로 구현해낼 수 있다. 

우리는 독자들에게 confidential transaction이 어떻게 작용하는지를 상기시키는 것으로 시작하려고 한다. 

첫째, 아래와 같은 방정식으로 금액을 코드화한다. 

C = r*G + v*H 

여기서 C는 Pedersen Commitment 이고, G와 H는 nothing-up-my-sleveliptic 곡선 그룹 생성기, v는 수량이며, r은 비밀 무작위 blinding key 이다. 

이 출력에 첨부된 rangeproof는 v가 0에서 2^64 사이에 있음을 증명하여 사용자가 블라인딩으로 오버플로 공격을 할 수 없도록 한다. 

거래를 검증하기 위해, 검증자는 모든 산출물에 f*H(여기에 명시적으로 주어진 거래 수수료)를 더하고 모든 투입 약속을 차감한다. 결과는 0이어야 하며, 이는 전체적으로는 금액의 면을 보았을 때, 중간에 생성되거나 파괴되지 않았다는 것을 증명한다. 

우리는 이러한 거래를 만들기 위해서, 사용자는 모든 투입의 시작이 되는 r의 전체 총액을 알아야 한다.(?) 그러므로 r의 값(그리고 그들의 총합)은 비밀키로 활용할 수 있다. 만약 우리가 r 출력값을 수신인만 알게 할 수 있게 한다면, 우리는 인증 시스템을 만든 것이다! 불행히도, 만약 모든 출력을 더하여 0이 되는 조건을 계속 유지해야한다면  지금은 불가능하다. 왜냐하면 송신자는 자신의 모든 r 값의 합을 알고 있기 때문에 다른 모든 수신인의 r 값을 제하면 0이 되기 떄문이다.(?) 그러므로 이 방법 대신 합이 0이 아닌 다른 값, k*G가 되는 것을 허용하고, 빈 문자열과 이를 서명한 키 값을 필요 항목으로 제시하여 총액을 구성요소들의 합이 0이 되도록 증명할 수 있도록 만들어야 한다. 

우리는 거래들이 최대한 많은 k*G 값을 서명과 합의 값을 갖고 이를 검증할 수 있도록 만든다. 

거래를 만들기 위해 송신인과 수신인은 다음의 절차를 따른다 : 

1.송신인과 수신인은 보낼 총액에 대해 합의한다. 이를 b라 명명한다.

2.송신인은 모든 입력과 나머지 출력값을 내는 거래를 만든다. 그리고 수신인에게 가려진 전체 요소(나머지 값의 r 값에서 입력값의 r 값을 뺀 것) 를 전달한다. commitment 의 값을 r*G - b*H 에 합친다. (?)

3.수신인은 임의의 r 값을 고른 뒤, b 에서 수수료를 뺀 값을 더하고 이를 (범위 증명과 함께)거래에 추가한다. 이제 투입의 합은 k*G - fee*H 이며 임의의 k는 수신인만 알고 있는 값이다.

4.수신인은 k를 포함한 서명을 거래에 부착하고, 수수료를 명확히한다. 이것으로 완료된것이다.

이제 이와 같은 방식은  OWAS에 도움을 준다. 이를 보여주기 위해, k1*G와 k2*G 만큼의 잉여분과 이에 대한 서명이 부착된 두개의 거래가 있다고 가정하자. k1 *G와 k2 *G를 섞어 두 거래의 입력과 출력을 결합할 수 있으며, 이 거래 또한 유효하다. 병합을 통해 어떤 출력 혹은 거래가 어느 거래에서 온 것인지 확인할 수 없게 된다.

이것으로 인해, 우리는 우리의 블록형태를 비트코인으로부터 블록 형식에서 다음과 같은 형태로 변화한다.

1.신규 유입된 돈의 명확한 총액 (블록 생산에 대한 보상이나 사이드체인의 peg-ins)과 필요로 하는 데이터. 사이드체인 peg-in의 경우 아마도 k*G 값을 초과하는 비트코인 거래의 정보?를 참조할 것이다

2.모든 거래의 입력들

3.모든 거래의 출력들

4.모든 거래의 초과 k*G 값들

이들 각각은 함께 그룹화되어지는데 , 원래 거래의 경계가 중요하지 않기 때문이다. 추가적으로, 두 번째부터 네 번째의 항목은 빠른 확인과 블록 생성자의 정보 누락을 방지하기 위해 알파벳 순으로 코딩 되어야할 것이다. 출력들은 이제 쉽게 변할 수 있는 거래 내의 위치가 아닌 해시의 형태로 고유화된다. 따라서 혼란을 피하기 위해 2개의 비사용(unspent) 출력이 동시에 동일하도록 하는 것이 금지되어야 한다.

[추가해석해야함]

<h3>블록을 넘어선 거래 병합(Merging Transactions Across Blocks)</h3>

우리는 Dr. Maxwell의 비밀 거래를 통해 사용자의 상호 활동을 필요로 하지 않는 CoinJoin을 만들었다. 하지만 아직 Dr. Maxwell의 마지막 놀라움을 다 본 것은 아니다. 우리는 다른 아이디어가 필요한데 이는 거래 컷스루(cut-through)로 그가 기술한 바 있다. 다시 한번 우리는 상호 활동이 필요없는 버전을 만들면서, 여러 블록에 걸쳐 이것이 사용되는지 보여주겠다.

우리는 이제 각각의 블록을 하나의 거대한 거래로 볼 수 있다. 이를 검증하기 위해서, 우리는 모든 출력 투입을 더하고, 모든 입력 투입과 k*G 값, 그리고 모든 명확한 출력 H를 공제하였다. 이것을 통해 우리는 두 블록을 병합할 수 있으며, 이를 하나의 블록으로 만들 수 있고, 이 또한 유효한 거래가 된다는 것을 발견하였다. 어떤 출력 투입은 이와 정확히 일치하는 입력 투입 쌍을 가지고 첫 블록의 출력은 두번째 블록에서 소비될 수 있다. 우리는 여기서 쌍이되는 두 투입을 삭제하더라도 거래의 유효성을 유지할 수 있다. 사실,  삭제된 출력의 범위 증명(rangeproof)을 검증할 필요도 없다.

이 아이디어를 제네시스 블록부터 최종 블록까지 전체로 확장하면, 우리는 출력과 연관된 명확하지 않은 모든 입력을 삭제할 수 있다. 남는 것은 미사용 출력 뿐이며,  이는 명확한 입력량과 k*G 값이다. 그리고 이러한 거대한 뒤섞임은 하나의 거래의 형태로 검증이 가능하다: 모든 미사용 출력 투입을 더하고, k*G 값을 빼서 명확한 입력량을 검증하고(만약 검증할 어떤 것이 있다면) 그리고 여기에서 최종적으로 H를 뺀다. 만약 합이 0이라면 전체 체인은 정상으로 판단할 수 있다.

이것은 무엇을 의미하는가? 어떤 사용자가 체인을 다운로드, 업로드를 한다면 매 블록 다음의 데이터를 필요로 한다:

1.신규 유입된 돈의(블록 보상이나 사이드체인 페깅으로 인한) 명확한 총액 그리고 이와 관련된 어떤 형태의 데이터

2.모든 거래의 미사용 출력이 머클(merkle) 증명의 형태로 원래의 블록에 구현된 정보

3.모든 거래의 초과된 k*G 값

현재 비트코인은 약 423,000 블록을 생성하였고, 이는 총 80GB에 달한다 또한 전체를 검증한다는 것은 이 방대한 데이터를 모두 살펴보는 것을 뜻한다. 이들 정보는 1억 5천만개의 거래와 5백만 개의 미분류의 미사용 출력으로 구성된다. Mimblewimble 체인의 트랜잭션 수가 차지하는 공간을 추정해보자. 각각의 미사용 출력은 약 3Kb의 범위증명과 머클 증명으로 처리된다. 각 거래는 또한 약 100 바이트를 추가로 필요로 한다: k*G 값과 서명.   블록 헤더들과 명백한 총액은 무시해도 된다. 이를 다 더하고도 30Gb가 남는다 -- 더불어 비밀의 거래와 모호한 거래 흐름까지!

<h3>Questions and Intuition 의문과 직감 </h3>

아래는 수 주 동안 나를 악몽에 시달리게 한 내용들이다. 하지만 결과적으로 괜찮을 것 같다.

Q. 만약 거래 출력을 삭제하면, 사용자는 범위증명을 검증하지 못하고 아마도 부채 출력을 만드는 것이 아닌가?

A. 이는 괜찮다. 전체 거래의 검증 차원에서 부채 출력은 이미 삭제되었어야만 한다. 사용자는SPV 보안을 통해 불법적인 인플레이션이 일어나지 않았다는 것을 알고, 지금 시점에서도 그렇다면 현재 인플레이션은 없음을 의미한다.

Q. 만약 입력값을 삭제하면 이중 지불(double spending)도 일어날 수 있지 않은가?

A. 사실 이것의 의미는: 만약 누군가가 어떤 미사용 출력이 이전에 사용되었다고 선언한 것이다. 하지만 이는 불가능하다. 그렇지 않으면 애초에 연결된 거래의 합이 0이 될수 없기 때문이다.

예외는 출력의 총액이 0일 때인데, 상대적으로 상쇄될 때와, 어떤 룰도 깨지않고 쌍으로 회복될 때 가능하다. 그래서 합의 문제를 피하기 위해, 출력 총액이 0인 것은 제외해야 한다. H를 모든 출력에 더하여 모든 출력이 최소한 1이 되도록 하면 된다.

<h3> Future Research 추후 연구과제 </h3>

 다음의 내용은 작성 시점에 내가 답할수 없는 것들이다.

1. 어떤 script support가 가능한가? 우리는 스크립트 작업을 일종의 개별 로그 정보로 번환할 필요가 있을것이다.

2. 사용자가 사용한 합이 k*G를 구성할 때 ,우리는 사용자가 모든 k*G 값을 체크하도록 요구한다. 서명을 사용하는 대신 결합이 가능한 다른 개별 로그 증명 방식은 없는가?

3. 사용자가 체인 데이터를 다운로드 받을 때, 수 기가바이트(Gb)에 달하는 잘못된 미사용 출력을 제공하는 DoS 공격이 가능하다. 사용자는 결과가 0이 아니더라도 문제가 어디인지는 확인할 수 없다.

지금 시점에서는 아마도 사용자는 블록체인 데이터를 데이터가 많은 사용자 간에 공유되고 합리적으로 정확할 가능성이 있는 토렌트 또는 다른 곳에서 받아야 한다.

[1] https://people.xiph.org/~greg/confidential_values.txt
[2] https://bitcointalk.org/index.php?topic=279249.0
[3] https://cryptonote.org/whitepaper.pdf
[4] https://eprint.iacr.org/2015/1098.pdf
[5] https://download.wpsoftware.net/bitcoin/wizardry/horasyuanmouton-owas.pdf
[6] http://blockstream.com/sidechains.pdf
[7] http://fr.harrypotter.wikia.com/wiki/Sortilège_de_Langue_de_Plomb
[8] https://bitcointalk.org/index.php?topic=281848.0